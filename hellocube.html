<!DOCTYPE HTML>
<html lang="en">
	<head>
		<title>GLOW - Hello Cube - Please Check Source</title>
		<meta charset="utf-8">
        <script type="text/javascript" src="http://code.jquery.com/jquery-1.10.2.min.js"></script>
        <script type="text/javascript" src="GLOW/build/custom/GLOWCore.js"></script>
		<script type="text/javascript" src="GLOW/build/custom/GLOWCoreMath.js"></script>
		<script type="text/javascript" src="GLOW/build/custom/GLOWExtras.js"></script>
        <script type="text/javascript" src="three.js"></script>
		<script type="text/javascript" src="GLOW/build/custom/GLOWThreeCompatibility.js"></script>
		<script type="text/javascript" src="OBJLoader.js"></script>
        <script type="text/javascript" src="util/webgl-utils.js"></script>
        <script type="text/javascript" src="util/glMatrix-0.9.5.min.js"></script>
        <script type="text/javascript" src="util/camera.js"></script>
        <script type="text/javascript" src="Obj.js"></script>
        <script id="vertex-default" type="x-shader/x-vertex">
            uniform	mat4 	transform;
			uniform 	mat4 	cameraInverse;
			uniform 	mat4 	cameraProjection;
			attribute 	vec3 	vertices;
			attribute  vec3	normals;
			attribute  vec2    uvs;
			attribute  float random;

			varying    vec2    uv;
			varying    float   light;

			void main(void)
			{
				uv = uvs;
				light = dot( normalize( mat3( transform[0].xyz, transform[1].xyz, transform[2].xyz ) * normals ), vec3( 0.0, 0.0, 1.0 ));
				gl_Position = cameraProjection * cameraInverse * transform * vec4( vertices, 1.0 );
			}
        </script>

        <script id="fragment-default" type="x-shader/x-fragment">
            #ifdef GL_ES
			precision highp float;
			#endif

			uniform 	sampler2D 	texture;
			varying    float  	 	light;
			varying 	vec2		uv;

			void main( void )
			{
				//gl_FragColor = texture2D( texture, uv ) * light;
				gl_FragColor = vec4(0.7,0.4,0.4,1.0);
			}
        </script>
        <script id="fragment-phong" type="x-shader/x-fragment">
            vec3 light_pos;
            vec3 viewer;
            vec3 lighting(vec3 vertex_pos, vec3 normal, vec3 viewer_pos, Material material) {
                vec3 l = light.pos - vertex_pos;
                float d = length(l);
                l = normalize(l);
                vec3 v = normalize(viewer_pos - vertex_pos);
                vec3 h = normalize((l + v)/2.0);
                float c_diffuse = max(0.0, dot(normal, l));
                float c_specular = pow(max(0.0, dot(normal, h)), material.shininess);
                float attenuation = 1.0/(light.constantAttenuation + pow(d, light.quadraticAttenuation));
                return attenuation*(c_diffuse*material.diffuse + c_specular*material.specular);
            }
        </script>
        <script type="text/javascript">
            function getShaderCode(id){
                var shaderScript = document.getElementById(id);
                if (!shaderScript) {
                    return null;
                }

                var str = "";
                var k = shaderScript.firstChild;
                while (k) {
                    if (k.nodeType == 3) {
                        str += k.textContent;
                    }
                    k = k.nextSibling;
                }
                return str;
            }

            // To get GLOW going, you need to create a GLOW.Context
			// We also set the background color to white
            var context = new GLOW.Context( { clear: { red: 1, green: 1, blue: 1 } } );
            var scene = [];
            var camera;
            var aff;
            var threejsMeshShader = {
                vertexShader: getShaderCode('vertex-default'),
                fragmentShader: getShaderCode('fragment-default'),
                data: {
                    transform: "matrixWorld",
                    cameraInverse: GLOW.defaultCamera.inverse,
                    cameraProjection: GLOW.defaultCamera.projection,
                    vertices: "vertices",
                    colors: "colors"
                },
                elements: "setByCode"
            }

            function start(){
                init();
                animate();
            }

            function animate() {
				render();
                requestAnimFrame( animate );
            }

            function init(){
                var container = document.getElementById( "container" );
			    container.appendChild( context.domElement );

                cubeShaderInfo = {
                    vertexShader: getShaderCode('vertex-default'),
                    fragmentShader: getShaderCode('fragment-default'),
                    data: {
                        // create uniform data
                        transform: new GLOW.Matrix4(),
                        cameraInverse: GLOW.defaultCamera.inverse,
                        cameraProjection: GLOW.defaultCamera.projection,
                        texture: new GLOW.Texture( { url:"star.gif" } ),

                        // create attribute data
                        vertices: GLOW.Geometry.Cube.vertices( 5 ),
                        uvs: GLOW.Geometry.Cube.uvs(),
                        normals: GLOW.Geometry.faceNormals( GLOW.Geometry.Cube.vertices(), GLOW.Geometry.Cube.indices())
                    },

                    // create element data
                    indices: GLOW.Geometry.Cube.indices(),
                    primitives: GLOW.Geometry.Cube.primitives()
			    }
                affShaderInfo = {
                    vertexShader: getShaderCode('vertex-default'),
                    fragmentShader: getShaderCode('fragment-default'),
                    data: {
                        // create uniform data
                        transform: new GLOW.Matrix4(),
                        cameraInverse: GLOW.defaultCamera.inverse,
                        cameraProjection: GLOW.defaultCamera.projection,
                        texture: new GLOW.Texture( { url:"star.gif" } ),

                        // create attribute data
                    },

                    // create element data
                    primitives: GL.TRIANGLES
			    }

                cube = new GLOW.Shader( cubeShaderInfo );

                GLOW.defaultCamera.localMatrix.setPosition( 0, 0, 1500 );
			    GLOW.defaultCamera.update();
                camera = new FPSCamera();
                camera.setPosition(0,0,15);
                initObjects();
            }

            function render() {
				// clear the context's cache and graphics
				context.cache.clear();
				context.clear();

				cube.transform.addRotation( 0.01, 0.005, 0.0025 );
                cube.cameraInverse.value = camera.getViewMat();
//                alert(cube.vertices.length);
//				cube.draw();
                aff.draw();
			}

            function initObjects() {
                $.ajax({
                    url:'aff.obj',
                    type: 'GET',
                    dataType: 'text',
                    async: false,
                    success: function(data){
                        var asi = readOBJ(data);
                        for (i in asi){
                            console.log(asi[i].vertices);
                            affShaderInfo.data.vertices = asi[i].vertices;
                            affShaderInfo.data.normals = asi[i].normals;
                            affShaderInfo.indices = asi[i].faces;
                            affShaderInfo.data.uvs = asi[i].UVs;
                            aff = new GLOW.Shader(affShaderInfo);
                        }
                    }
                });
            }
        </script>

	</head>
	<body onload="start()">
		<div id="container"></div>
	</body>
</html>
