<!DOCTYPE HTML>
<html lang="en">
	<head>
		<title>GLOW - Hello Cube - Please Check Source</title>
		<meta charset="utf-8">
        <script type="text/javascript" src="http://code.jquery.com/jquery-1.10.2.min.js"></script>
        <script type="text/javascript" src="GLOW/build/custom/GLOWCore.js"></script>
		<script type="text/javascript" src="GLOW/build/custom/GLOWCoreMath.js"></script>
		<script type="text/javascript" src="GLOW/build/custom/GLOWExtras.js"></script>
        <script type="text/javascript" src="three.js"></script>
		<script type="text/javascript" src="GLOW/build/custom/GLOWThreeCompatibility.js"></script>
		<script type="text/javascript" src="OBJLoader.js"></script>
        <script type="text/javascript" src="util/webgl-utils.js"></script>
        <script type="text/javascript" src="util/glMatrix-0.9.5.min.js"></script>
        <script type="text/javascript" src="util/camera.js"></script>
        <script type="text/javascript" src="Obj.js"></script>
        <script id="vertex-default" type="x-shader/x-vertex">
            uniform	mat4 	transform;
            uniform mat3    normalMatrix;
			uniform 	mat4 	cameraInverse;
			uniform 	mat4 	cameraProjection;
			attribute 	vec3 	vertices;
			attribute  vec3	normals;

			varying    vec2    uv;
			varying    float   light;
			varying    vec3 vertex_pos;
			varying    vec3 normal;

			void main(void)
			{
				gl_Position = cameraProjection * cameraInverse * transform * vec4( vertices, 1.0 );
				vertex_pos = vec3(cameraInverse * transform * vec4(vertices,1.0));
				normal = normalMatrix * normals;
			}
        </script>

        <script id="fragment-default" type="x-shader/x-fragment">
            #ifdef GL_ES
			precision highp float;
			#endif

			uniform 	sampler2D 	texture;
			varying    float  	 	light;
			varying 	vec2		uv;

			void main( void )
			{
				//gl_FragColor = texture2D( texture, uv ) * light;
				gl_FragColor = vec4(0.7,0.4,0.4,1.0);
			}
        </script>
        <script id="fragment-phong" type="x-shader/x-fragment">
            #ifdef GL_ES
			precision highp float;
			#endif

            varying vec3  vertex_pos;
            vec3 light_pos;
            vec3 viewer;

    //        vec3 lighting(vec3 vertex_pos, vec3 normal, vec3 viewer_pos, Material material) {
    //            vec3 l = light.pos - vertex_pos;
    //            float d = length(l);
    //            l = normalize(l);
    //            vec3 v = normalize(viewer_pos - vertex_pos);
    //            vec3 h = normalize((l + v)/2.0);
    //            float c_diffuse = max(0.0, dot(normal, l));
    //            float c_specular = pow(max(0.0, dot(normal, h)), material.shininess);
    //            float attenuation = 1.0/(light.constantAttenuation + pow(d, light.quadraticAttenuation));
    //            return attenuation*(c_diffuse*material.diffuse + c_specular*material.specular);

    //        }
            void main( void )
            {
                gl_FragColor = vec4(0.7,0.5,0.5,1.0);
            }
        </script>
        <script type="text/javascript">
            function getShaderCode(id){
                var shaderScript = document.getElementById(id);
                if (!shaderScript) {
                    return null;
                }

                var str = "";
                var k = shaderScript.firstChild;
                while (k) {
                    if (k.nodeType == 3) {
                        str += k.textContent;
                    }
                    k = k.nextSibling;
                }
                return str;
            }

            // To get GLOW going, you need to create a GLOW.Context
			// We also set the background color to white
            var context = new GLOW.Context( { clear: { red: 1, green: 1, blue: 1 } } );
            var scene = [];
            var camera;
            var aff;
            var compiledShaderInfo = {
                vertexShader: getShaderCode('vertex-default'),
                fragmentShader: getShaderCode('fragment-phong'),
                data: {
                    cameraInverse: GLOW.defaultCamera.inverse,
                    cameraProjection: GLOW.defaultCamera.projection,
                },
            }
            var compiledShader;

            function start(){
                init();
                animate();
            }

            function animate() {
				render();
                requestAnimFrame( animate );
            }

            function init(){
                var container = document.getElementById( "container" );
			    container.appendChild( context.domElement );

                cubeShaderInfo = {
                    vertexShader: getShaderCode('vertex-default'),
                    fragmentShader: getShaderCode('fragment-default'),
                    data: {
                        // create uniform data
                        transform: new GLOW.Matrix4(),
                        cameraInverse: GLOW.defaultCamera.inverse,
                        cameraProjection: GLOW.defaultCamera.projection,
                        texture: new GLOW.Texture( { url:"star.gif" } ),

                        // create attribute data
                        vertices: GLOW.Geometry.Cube.vertices( 5 ),
                        uvs: GLOW.Geometry.Cube.uvs(),
                        normals: GLOW.Geometry.faceNormals( GLOW.Geometry.Cube.vertices(), GLOW.Geometry.Cube.indices())
                    },

                    // create element data
                    indices: GLOW.Geometry.Cube.indices(),
                    primitives: GLOW.Geometry.Cube.primitives()
			    }
                affShaderInfo = {
                    vertexShader: getShaderCode('vertex-default'),
                    fragmentShader: getShaderCode('fragment-default'),
                    data: {
                        // create uniform data
                        transform: new GLOW.Matrix4(),
                        cameraInverse: GLOW.defaultCamera.inverse,
                        cameraProjection: GLOW.defaultCamera.projection,
                        texture: new GLOW.Texture( { url:"star.gif" } ),

                        // create attribute data
                    },

                    // create element data
                    primitives: GL.TRIANGLES
			    }

                compiledShader = new GLOW.Compiler.compile(compiledShaderInfo);

                GLOW.defaultCamera.localMatrix.setPosition( 0, 0, 1500 );
			    GLOW.defaultCamera.update();
                camera = new FPSCamera();
                camera.setPosition(0,0,15);
                initObjects();
            }

            function render() {
				// clear the context's cache and graphics
				context.cache.clear();
				context.clear();

//				cube.transform.addRotation( 0.01, 0.005, 0.0025 );
                compiledShader.cameraInverse.value = camera.getViewMat();
//                alert(cube.vertices.length);
//				cube.draw();
                for(obj in scene){
                    obj.draw();
                }
			}

            function initObjects() {
                var MVMatrix = new GLOW.Matrix4();
                MVMatrix.addRotation(0.0, 90.0, 0.0);

                //setup the normal matrix from the transformation matrix
                var normalMatrix = MVMatrix.clone();
                normalMatrix.invert();
                normalMatrix.transpose();
                var nMatrix = new GLOW.Matrix3();
                nMatrix.extractFromMatrix4(normalMatrix);

                $.ajax({
                    url:'aff.obj',
                    type: 'GET',
                    dataType: 'text',
                    async: false,
                    success: function(data){
                        var asi = readOBJ(data);
                        for (i in asi){
                            var obj = new GLOW.Shader({
                                use: compiledShader,
                                except: {
                                    transform: MVMatrix,
                                    normalMatrix: nMatrix,
                                    vertices: asi[i].vertices,
                                    normals: asi[i].normals,
                                    indices: asi[i].faces,
                                    uvs: asi[i].UVs,
                                }
                            });
                            scene.push(obj);
                        }
                    }
                });
            }
        </script>

	</head>
	<body onload="start()">
		<div id="container"></div>
	</body>
</html>
